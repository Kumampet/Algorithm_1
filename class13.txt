アルゴリズムとデータ構造　13回目

コーディング試験のアナウンス

ヒューリスティックサーチ
・基本は探索
問題解決に最適なアルゴリズムが存在しないときの対処法->探索でしか解けない

＊8Queens Problem(チェス問題)
nxnのチェス盤に8体のクイーンを置いて、互いを襲撃しないような配置を探すとき
この答えを求めるには探索をするしかない->多少の効率化はできる
一番シンプルな方法->64マスから8体のとき＝約4億回の試行
たかだか1行(列)には1体くらいしか置けないのでおおよそ8!≒4万
深さ優先探索を利用するとよい
後戻りする->Backtracking
チェス盤の縦をi,横をyとして0オリジン
i行目にクイーンを配置する再起関数を用意
for i = 0  to n
横方向に見て行っておけるところにとにかくおいていく
置いた個数が総数と一致したら終了
途中で試行が失敗したら戻る
実装のポイント：i行目のどこに置いたか。
[スライド１２]
row[i]を用意->i行目のクイーンの位置を格納(列番号)
col[i]を用意->列iが襲撃されているかのbool
斜めの襲撃は？
[スライド１３]
N->盤面のサイズ
putQueen(i)//i行目に置く
  if i == N
    printBoard()//盤面のプリント
    return
  for j = 0 to N-1//列の探索
    if col[j] == NOT_FREE ||//j列目が何かに襲撃されている
        dpos[i+j] == NOT_FREE || dneg[i-j+N-1] == NOT_FREE//斜めも襲撃されている
      continue
    // put a queen at (i, j)
    row[i] = j//上記条件をクリアすれば置く
    col[j] = dpos[i+j] = dneg[i-j+N-1] = NOT_FREE//今置いたクイーンによって襲撃済みを更新
    // try the next row
    putQueen(i+1)//次の行に対して実行
    // remove the queen at (i, j) for backtracking
    col[j] = dpos[i+j] = dneg[i-j+N-1] = FREE//置いたクイーンを取り除く

＊8 Puzzle Problem
3x3パネルで空いた1マスを利用してパネルを動かして何かするアレ

ツリー(グラフ)を利用する
バーテックスが数字から盤面になった
各バーテックスから移動できるパターンを格納して繰り返す
深さ優先探索か幅優先探索：幅優先探索だと最小が一回で出る
難しいところ：ノードの訪問状態をcolorでとっていたのをハッシュ関数で定義する
C+とかだとそういう関数あるよね～

やりやすい方法：幅優先探索をかける
最短手数を求めることができる
パズルの状態(state)をメモリに入れなくてはいけない->難しい
15pになるともう使えない->Depth Limit Search
Depth Limit Search
深さに制限を付けてそれ以上いかない
パズルの局面をメモリに取らない
一個前に戻らないように細工しておけば大丈夫
あとはひたすら巡っていく
Iterative Deepening(反復深化)
Depth Limit Searchの上限を0から初めてDepth Limit Searchをかけて解が求まるまで再起する
解が得られた時の深さが最短手数になる
もう一工夫->ヒューリスティック
探索の枝を張る->これ以上探索をしても無駄になる点がある
[スライド３０]
今の手数がｄを超えてれば試行が無駄である
[スライド３２]
ゴール状態にないパネルを数える
この場合は少なくとも7手が必要
[スライド３３]
マンハッタン距離
すべての盤面が正解の位置に行くまでの最短の手数の総和をだす


うーんわからん
覚えておけばいいのはバックトラックとかバックトラックとかバックトラックとか・・・by渡辺
