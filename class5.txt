アルゴリズムとデータ構造　5回目

再帰(Recursion)≒スタックで考える
関数で自分自身で呼び出す
終了条件を必ず含ませる。

ex)与えられた整数を2進数で表現する[スライド4]
toBinary(x)
	if x > 0
		toBinary(x/2)
		print x%2
call toBinary(input)

toBinary(1)→１
toBinary(2)→0
toBinary(5)→1
toBinary(10)→0
toBinary(21)→1
toBinary(43)→1
toBinary(86)→0
終わってない処理をスタックで積み上げていく感覚
終わったら上から表示していく

余談：メモリ
スタック領域：関数や変数を格納、スタックもここ。サイズが小さい(8mbyt)。再帰関数が深くなるとここをガリガリ削っていく。やめておく。一つの関数で大きなメモリを使いすぎない。動的に確保する。
ヒープ領域：グローバル変数や動的変数確保を格納

分割統治法(Divide and Conquer)
与えられた問題PをアルゴリズムAで解く。最終問題は解くこと。問題Pが大きい時、分割して考える。この時アルゴリズムAも分割する。
P-A, P'-A', P''-A''.........................
再帰的に小さい問題から解決する。
問題自体は同じでもサイズを小さくしてあったりする。

ex)ある配列が与えられているとき、この中から最大値を探す
findMax(A, left, right)//配列Aの桓階区間
	m = (left + right)/2
	if left == right-1
		return A[left]
	else
		u = findMax(A, left, m)
		v = findMax(A, m, right)
		if u > v
			return u
		else
			return v
木構造で見るとトーナメントっぽい

計算量
各階層で何回計算が行われるか。(何個の要素を比べているか)
計算量はO(n)→forループと変わらない

マージソート(今回のメイン)
merge(A, l, m, r)
	n1 = m - l//配列Aの要素数
	n2 = r - m//配列Bno要素数
	create an array L[0..n1]
	create an array R[0..n2]
	for i = 0 to n1-1
		L[i] = A[l+i]
	for j = 0 to n2-1
		R[j] = A[m+j]
	L[n1] = SENTINEL
	R[n2] = SENTINEL
	i = 0
	j = 0
	for k = l to r-1
		if L[i] < R[j]
			A[k] = L[i]
			i = i+1
		else
			A[k] = R[j]
			j = j+1
今までやったソートアルゴリズムは遅い
分割統治法に基づいたアルゴリズム
マージというプロセス：二つの配列をマージする(統合)
例：二つの昇順に並んだ配列を一本の配列にマージする
注：二つの配列はすでに昇順で並んでる
目的:O(n)でやりたい
それぞれの配列の先頭要素のみ比較してマージしていく
二つに分けた配列のケツには∞(要素の最大値より大きい値)の番兵を置いておく
mergeSort(A, left, right)
	if left + 1 < right//終了条件
	mid = (left + right)/2
	mergeSort(A, left, mid)
	mergeSort(A, mid, right)
	//ここまでに左半分と右半分のソートがそれぞれ終わっていることが保証される
	merge(A, left, mid, right)

計算量はO(n logn)とても速いかつ安定
欠点：クイックソートと比べて外部ソートと呼ばれ、入力以外のメモリが必要である。
いままでのソートは確保した一本の配列メモリでできる。
マージソートは入力した配列のほかに、分割した分の配列が必要→つまり2倍のメモリ量が必要
