アルゴリズムとデータ構造　11回目

グラフ構造
Directed Graph
要素に関連性があり結びつきに方向を持つ
Undirected Graph
要素に関連性があるが相互に結びつきを持つ(方向は問わない)

グラフ：データ構造
世の中のあらゆることはグラフで表せる
例：SNSの友達関係
人：バーテックス
関係：エッジ
エッジに重みをもたせることもできる
例：距離、所要時間、運賃etc...

グラフをメモリに確保する
・隣接行列
・隣接リスト

＊隣接行列[スライド11]
|V|のときVxVの正方行列で表し、バーテックスに関係がある(i, j)に１が入る
この時対角線で対象になる。
計算効率が悪い
メモリも結構食う

＊隣接リスト[スライド14]
バーテックスに対して、どこに矢印が向かっているかをリスト化する。
効率がいい
あるノード間のエッジの有無を答えるときに時間がかかる。(実問題ではあまり問題ではない)

隣接リストで実装したほうがはるかに効率がいい

Depth First Search(深さ優先探索)
グラフが与えられたときにバーテックスを体系的に訪問する
バーテックスを行けるとこまで深くたどる
スタックを使う
2種類のタイムスタンプを押す[スライド20]
d[v]：一番最初に発見した時刻(discover)
f[v]：探索を完了した時間
初期化処理：スタート地点をスタックに入れる
スタックの頂点を見る
0を発見する
時刻を記入する-> d[v]/f[v]
頂点につながっている次のエッジを順番に見る
その先のバーテックスをスタックに入れる
以降繰り返す
最後まで行き、探索先がなくなったら取り出し始めてf[v]を押す
スタックからトップを取り出す
トップのノードを見る
繰り返す
戻る途中で見訪問先があったら訪問する。

[スライド37]
再帰を使う
すっきりする

深さ優先探索は初期化にV回の処理
＊隣接行列で実装した場合
O(|V|^2)
＊隣接リストで実装した場合
O(|V|+|E|)

Breadth First Search(幅優先探索)[スライド43]
スタックをキューに変えるだけ
スタート地点からエッジの本数(距離)に比例してバーテックスを見る
キューに入れる
スタート地点からの距離を更新
