アルゴリズムとデータ構造　8回目

二分探索木(Binary Search Trees)
似たような構造はリスト構造
リスト構造を理解してない場合は早急に理解する
最小値、最大値を高速で読み出せる
ハッシュと同じようなことができる
とにかくいろいろ速い

ある要素は
＋親へのポインタ
＋左の子のポインタ
＋右ノ子へのポインタ
を持つ
二分探索木条件を持たなければならない
＋xの左子孫をyとすると y.key<=x.key
＋xの右子孫をzとすると z.key>=x.key
＋上記が再帰的に実装されている

Inorder Tree Walkを使うとご利益がある。
中のキーを小さい順に取り出せる→昇順で取り出せる

オペレーション->そのアルゴリズムができる機能

Tree Search[スライド１０]
現在地をx、探したい要素をkとすると
二分探索と同じ原理で以下ができる
rootを起点にしてサーチしていく
treeSearch(x, k)
  if x == NIL or k == x.key
    return x
  if k < x.key
    return treeSearch(x.left, k)
  else
    return treeSearch(x.right, k)
二分探索木条件が成り立っていれば確実に探せる

最小値、最大値探索
＋最小値
nilになるまで(子を持たないところ)左側の要素をずっとたどっていく
＋最大値
nilになるまで(子を持たないところ)右側の要素をずっとたどっていく

次接点(次のキー)Successor[スライド１５－１６]
xについて
+右に一個下って左の最小値
+右の子を持たないときは親をたどっていって、右に曲がったときの親
上記の条件がxの次接点
treeSuccessor(x)
  if x.right != NIL
    return treeMinimum(x.right) // case 1
  y = x.p
  while y != NIL and x == y.right
    x = y
    y = y.p
  return y // case 2
直接使われることはないが、ノードを削除するときに必要になる

Insert and Delate
動的にする場合は、二分探索木条件を遵守させる
＋挿入
現在あるものに新しいノードを加える
新しく加えるノードzは子を持たない
新しいノードはどこかのnilに必ず入る[スライド２０]
サーチしてその値が適切な大小関係を持つnilが見つかったところに入れる
treeInsert(T, z)
  y = NIL
  x = T.root
  while x != NIL
    y = x
    if z.key < x.key
      x = x.left
    else
      x = x.right
  z.p = y//zの親をyに設定する
  if y == NIL // Tree is empty
    T.root = z
  else if z.key < y.key
    y.left = z//yの子を設定する
  else
    y.right = z//yの子を設定する
＋削除
二分探索木からあるノードを削除する
３パターンから考える[スライド２２]
＋パターン１
削除ノード（ｚ）に子がない場合
ただ消すだけではだめ
zの子をnilの子にする
＋パターン２
zが子を１つだけ持つ場合
zの親のポインタをzの子の親ポインタに書き換える
＋パターン３
zが子を２つもつ場合
一番めんどくさい
zの次接点をzにコピーする
zの次接点を消す
[スライド２５，２６]
treeDelete(T, z)
01. if z.left == NIL or z.right == NIL
02.   y = z //y:消すノードの候補case1,case2はz=y
03. else //つまりcase3
04.   y = Tree-Successor(z)
05.//-----------------------ここまでが前処理------------------------
06. if y.left != NIL
07.   x = y.left //xはyの子
08. else
09.   x = y.right //case1ではnilがxになる
10.
11. if x != NIL
12.   x.p = y.p //xの親を決定
13. if y.p == NIL
14.   T.root = x
15. else if y == y.p.left //子供の左右を決定
16.   y.p.left = x
17. else
18.   y.p.right = x
19.
20. if y != z //yとzが一致しない場合
21.   z.key = y.key
