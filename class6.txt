アルゴリズムとデータ構造　5回目

ソート　
n:要素数の場合
k:配列内の一番大きい要素
//---初等的---
バブルソート:計算量->O(n^2)　安定性->O メモリ(空間計算量)->O(n) 内部的
挿入ソート:計算量->O(n^2) 安定性->O　メモリ(空間計算量)->O(n) 内部的
選択ソート:計算量->O(n^2) 安定性->X　メモリ(空間計算量)->O(n) 内部的
//---
マージソート:計算量->O(nlogn) 安定性->O　外部的　メモリ(空間計算量)->O(n) メモリをバカ食う
クイックソート:計算量->O(nlogn) 安定性->X　内部的　メモリ(空間計算量)->O(n) 考案されているソート内で最速　内部的でありながら早い。安定性に欠ける。
カウンティングソート計算量->O(n)安定性->O　外部的　メモリ(空間計算量)->O(k) 最大値が大きいほどメモリを食う　イマイチ

クイックソート
quickSort(A, p, r)
  if p < r
    q = partition(A, p, r)
    quickSort(A, p, q-1)
    quickSort(A, q+1, r)
コンバインの処理がいらない
分割した時点で解がある
マージソートとコードの規模が似ているが、内容が全く異なる。
パーティション処理->l-rまでをすべて含む(桓階区間ではない)
ランダムにある位置(ｑ)で軸を決める
qより小さいものを左へ、大きいものを右へ移動させる。
[スライド６]
右端のxを基準にする
やってることは簡単だけどアルゴリズム的には難しい
やりたいこと：小さいグループと大きいグループに分ける
最初はポインタiとjはlの位置にいる
xより大きい時はjを増やして空いたところに入れる
数字がx以下の時がトリッキー
大きいグループの先頭要素を終端に送り込んでからiとjをインクリメントして、挿入[スライド７]
順番は入れ替わるけど、グループ分けができていれば大丈夫
[スライド８]具体例

いい場合
軸がど真ん中にあるとき
毎回バランスよく配置されていればよい
悪い場合
軸が偏るとき
うまく分割されないとき
分割しても配列の要素数が減っていかない->効率が悪くなる
クイックソートの弱点
回避策：軸の値をランダムに区間内から選んであげると、確率的にうまくいく

カウンティングソート
メモリの最大値がO(k)
kがある程度小さいとわかっているときに適用
入力で与えられた数を数える[スライド３１]
kの値は例の場合だと６
つまり入力された数字が何回登場したかをみる
累積和をとる
累積和を取った配列を使ってソートする。
累積和はその数nの累積和の時点でその数nより小さい値はいくつ存在するかを意味する。
[スライド３３]
累積和の数字の添え字の配列に出力してあげればよい
カウンターはデクリメントすることを忘れずに
後ろから入れていくことによって安定性を保つことができる。
＊カウンティングソート概要
計算量はO(n)
メモリ量はO(k)
カウンティングソートは後ろからやることを徹底することによって安定する
