アルゴリズムとデータ構造　10回目

ダイナミックプログラミング(動的計画法)
計画法->プランニング
プログラミングのテクニックの一種(OOソートなどの手法のことではない)
分割統治法に似ている
部分問題に枝が増えたようなイメージ
適用すべき問題->部分問題の部分問題になっているとき
すでに計算された部分問題の解をメモリに取っていおいて、使うときは返すだけにしておく
うまく再利用する
再帰的に説く
漸化式と似ている

例：フィボナッチ数列
再帰的に定義できる
最大二つ前の項を利用して漸化式で解ける
fibonacci(n)//再帰的に求める場合
  if n == 0 || n == 1
    return 1
  return fibonacci(n - 2) + fibonacci(n - 1)
このコードには問題がある
同じパラメタの関数が大量に出てくる
項の数字の分だけ計算しなくてはいけない->大変効率が悪い
fibonacci(n) //動的計画法を使った場合
  if n == 0 || n == 1
    return F[n] = 1　//一次元配列に結果を保管しておく
  if F[n] is already defined
    return F[n]　//F[n]が計算済みだったらそのまま返す
  return F[n] = fibonacci(n - 2) + fibonacci(n - 1) //計算されてなかったら再帰的に呼び出して計算して返す
メモ化->メモリに記憶しておくこと
fibonacci(n)
  F[0] = 1
  F[1] = 1
  for i = 2 to n
    F[i] = F[i - 2] + F[i - 1]

例：組み合わせの数を求める
再帰的な漸化式で表現可能
nCk = n-1Ck + n-1Ck-1

例：パスカルの三角形
recursiveBinomial(n, k)
  if k == 0 or k == n
    return 1
  else
    u = recursiveBinomial(n-1, k)
    v = recursiveBinomial(n-1, k-1)
    return u + v

二次元配列に記憶する場合
典型的かつ簡単
dynamicBinomial(n, k)
  if dp[n, k] is already defined
    return dp[n, k]
  else
    if k == 0 or k == n
      dp[n, k] = 1
    else
      u = dynamicBiomial(n-1, k)
      v = dynamicBiomial(n-1, k-1)
      dp[n, k] = u + v
  return dp[n, k]

偏差的行列
計算回数を最も少なくなるようなパターンを出す
部分問題に分割
kは左から順番に増えていく
手計算だと馬鹿時間かかる
matrixChainOrder(p)
  n = p.length-1
  for i = 1 to n
    m[i, i] = 0
  for l = 2 to n
    for i = 1 to n-l+1
      j = i+l-1
      m[i, j] = INF
      for k = i to j-1
        q = m[i,k] + m[k+1, j] + p[i-1]*p[k]*p[j]
        m[i,j] = min(m[i,j], q)
計算量：O(n^3)

最小共通部分列
LCSLength(X, Y)
  m = X.length
  n = Y.length
  for i = 1 to m
    c[i,0] = 0
  for j = 0 to n
    c[0,j] = 0
  for i = 1 to m
    for j = 1 to n
      if X[i] == Y[j]
        c[i,j] = c[i-1, j-1] + 1
      else if c[i-1,j] >= c[i, j-1]
        c[i,j] = c[i-1,j]
      else
        c[i,j] = c[i,j-1]
